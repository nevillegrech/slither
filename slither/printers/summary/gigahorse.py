"""
    Module printing summary of the contract
"""

from slither.printers.abstract_printer import AbstractPrinter
from slither.slithir.operations import *
from slither.slithir.variables import \
    StateIRVariable, LocalIRVariable, ReferenceVariable,\
    Constant # SolidityVariableComposed
from slither.core.declarations.solidity_variables import SolidityVariableComposed, SolidityVariable
from collections import defaultdict

import pdb, traceback, sys, os

class LeftOrRightNode:
    def __init__(self, oldnode, i):
        if isinstance(oldnode, LeftOrRightNode):
            self.original_node = oldnode.oldnode
        else:
            self.original_node = oldnode
        self.oldnode = oldnode
        self.i = i
        if self.mode == 'r':
            self.sons = oldnode.sons

    @property
    def irs(self):
        if self.mode == 'l':
            return self.oldnode.irs[:self.i+1]
        if self.mode == 'r':
            return self.oldnode.irs[self.i+1:]

    @property
    def node_id(self):
        return '%s_%d%s'%(self.oldnode.node_id, self.i, self.mode)

    def __getattr__(self, f):
        assert f in {'function', 'expression'}
        return getattr(self.original_node, f)
        
class PrevNode(LeftOrRightNode):
    mode = 'l'
class NextNode(LeftOrRightNode):
    mode = 'r'

class Opcode:
    all_opcodes = set()
    
    def __init__(self, name, uses, defines, **kwargs):
        self.uses = uses
        self.defines = defines
        assert self.uses * self.defines >= 0, "Inconsistent"
        assert self.uses >= -1, "Value Error"
        assert self.defines >= -1, "Value Error"
        self.var_args = self.uses < 0
        self.name = name
        self.properties = kwargs
        Opcode.all_opcodes.add(self)

    def get_datalog_code(self):
        name = self.name
        if self.var_args:
            print('// %s opcode has variadic arguments')
            print('// use Statement_Uses and Statement_Defines')
            print('.decl %s(stmt: Statement)'%name)
            print('%(name)s(stmt) :- Statement_Opcode(stmt, "%(name)s").'%locals())
            print()
            return
        # else
        args = list('abcdefghijk')[:self.uses]
        if self.defines:
            args.append('res')
        decl_args = ', '.join(['stmt: Statement'] + ['%s: Variable'%a for a in args])
        bin_args = ', '.join(['stmt'] + args)
        print('.decl %(name)s(%(decl_args)s)'%locals())
        print('%(name)s(%(bin_args)s) :-'%locals())
        body = []
        body.append('Statement_Opcode(stmt, "%(name)s")'%locals())
        if self.defines:
            body.append('Statement_Defines(stmt, res, 0)')
        for n in range(self.uses):
            arg = args[n]
            body.append('Statement_Uses(stmt, %(arg)s, %(n)d)'%locals())
        print('    ' + (',\n    '.join(b%locals() for b in body)) + '.\n\n')
        for p, v in self.properties.items():
            if v:
                print('Opcode%(p)s("%(name)s").'%locals())
        
    @classmethod
    def print_all_datalog(cls):
        print('// The following code is generated by %s'%__name__)
        print()
        properties = set()
        for rel in cls.all_opcodes:
            properties|=set(rel.properties.keys())
        for p in properties:
            print('.decl Opcode%(p)s(op: Opcode)'%locals())
        print()
        for rel in cls.all_opcodes:
            rel.get_datalog_code()

    def __hash__(self):
        return 23+hash(self.name)

    def __eq__(self, other):
        return self.name == other.name
        
        

class FactRelation:
    types = defaultdict(lambda : 'symbol', {
        'block': 'Block',
        'next_block': 'Block',
        'statement': 'Statement',
        'statement2': 'Statement',
        'opcode': 'Opcode',
        'function': 'Function',
        'modifier': 'Modifier',
        'variable': 'Variable',
        'gas': 'Variable',
        'destination': 'Variable',
        'callvalue': 'Variable',
        'n': 'number',
        'contract': 'Contract',
        'global': 'GlobalVariable'
    })

    @classmethod
    def convert_node(cls, node):
        return node.function.canonical_name + '_' + str(node.node_id)
    @classmethod
    def convert_function(cls, function):
        return function.canonical_name
    @classmethod
    def convert_modifier(cls, modifier):
        return modifier.canonical_name

    @classmethod
    def convert_contract(cls, contract):
        return contract.name

    @classmethod
    def convert_opcode(cls, opcode):
        return opcode.name

    @classmethod
    def get_convertor(cls, name):
        convertors = {
            'block' : FactRelation.convert_node,
            'next_block' : FactRelation.convert_node,
            'function' : FactRelation.convert_function,
            'modifier' : FactRelation.convert_modifier,
            'contract' : FactRelation.convert_contract,
            'opcode' : FactRelation.convert_opcode,
        }
        if name in convertors:
            return convertors[name]
        return lambda a: a
    
    all_relations = []
    
    @classmethod
    def output_all_facts(cls):
        for rel in cls.all_relations:
            rel.output_facts()

    @classmethod
    def print_all_datalog(cls):
        print('// The following code is generated by %s'%__name__)
        for t in (set(cls.types.values()) - {'number', 'symbol'}):
            print('.type '+t)
        for rel in cls.all_relations:
            rel.get_datalog_code()
        
    
    def __init__(self, relname, names):
        FactRelation.all_relations.append(self)
        self.arity = len(names)
        self.names = names
        self.relname = relname
        self.innerset = set()

    def add(self, *args):
        assert len(args) == self.arity, [self.names, args]
        newargs = []
        for i, arg in enumerate(args):
            arg = self.get_convertor(self.names[i])(arg)
            assert isinstance(arg, (int, str)), arg
            newargs.append(arg)
        self.innerset.add(tuple(newargs))

    def get_datalog_code(self):
        relname = self.relname
        args = ', '.join(n+': '+self.types[n] for n in self.names)
        print('.decl %(relname)s(%(args)s)\n.input %(relname)s\n'%locals())

    def output_facts(self):
        with open(self.relname+'.facts', 'w') as f:
            # sort relations by leftmost column
            try:
                setsorted = sorted(list(self.innerset), key = lambda a: a[0])
            except Exception:
                setsorted = self.innerset
            for rel in setsorted:
                f.write('\t'.join(str(r) for r in rel))
                f.write('\n')

binary_type_to_opcode = {
    BinaryType.POWER : Opcode('EXP', 2, 1),
    BinaryType.MULTIPLICATION : Opcode('MUL', 2, 1),
    BinaryType.DIVISION : Opcode('DIV', 2, 1),
    BinaryType.MODULO : Opcode('MOD', 2, 1),
    BinaryType.ADDITION : Opcode('ADD', 2, 1),
    BinaryType.SUBTRACTION : Opcode('SUB', 2, 1),
    BinaryType.LEFT_SHIFT : Opcode('SHL', 2, 1),
    BinaryType.RIGHT_SHIFT : Opcode('SHR', 2, 1),
    BinaryType.AND : Opcode('AND', 2, 1),
    BinaryType.CARET : Opcode('XOR', 2, 1),
    BinaryType.OR : Opcode('OR', 2, 1),
    BinaryType.LESS : Opcode('LT', 2, 1),
    BinaryType.GREATER : Opcode('GT', 2, 1),
    BinaryType.LESS_EQUAL : Opcode('LEQ', 2, 1),
    BinaryType.GREATER_EQUAL : Opcode('GEQ', 2, 1),
    BinaryType.EQUAL : Opcode('EQ', 2, 1),
    BinaryType.NOT_EQUAL : Opcode('NEQ', 2, 1),
    BinaryType.ANDAND : Opcode('ANDAND', 2, 1),
    BinaryType.OROR : Opcode('OROR', 2, 1),
}

unary_opcodes = [ Opcode('NOT', 1, 1) ]

builtin_translations = {
    'msg.sender' : Opcode('CALLER', 0, 1),
    'msg.value' : Opcode('CALLVALUE', 0, 1),
    'block.blockhash' : Opcode('BLOCKHASH', 1, 1),
    'block.coinbase' : Opcode('COINBASE', 1, 1),
    'block.difficulty' : Opcode('DIFFICULTY', 0, 1),
    'block.gaslimit' : Opcode('GASLIMIT', 0, 1),
    'block.number' : Opcode('NUMBER', 0, 1),
    'msg.gas' : Opcode('GAS', 0, 1),
    'extcodesize' : Opcode('EXTCODESIZE', 1, 1),
    'msg.data.length()' : Opcode('CALLDATASIZE', 0, 1),
    'block.timestamp' : Opcode('TIMESTAMP', 0, 1),
    'tx.gasprice' : Opcode('GASPRICE', 0, 1),
    'tx.origin' : Opcode('ORIGIN', 0, 1),
    'selfdestruct' : Opcode('SELFDESTRUCT', 1, 0, PossiblyHalts = True),
    'this': Opcode('ADDRESS', 0, 1),
}

solidity_function_to_opcode = {
    'require(bool)' : Opcode('REQUIRE', 1, 0),
    'assert(bool)' : Opcode('ASSERT', 1, 0),
}

class PrinterGigahorse(AbstractPrinter):

    ARGUMENT = 'gigahorse'
    HELP = 'Output gigahorse facts representation of the functions'
    WIKI = 'https://github.com'

    def output(self, _directory):
        """
            Args:
                _directory(string)

        """
        is_contract = FactRelation('IsContract', ['contract'])
        contract_modifier = FactRelation('Contract_Modifier', ['contract', 'modifier'])
        contract_function = FactRelation('Contract_Function', ['contract', 'function'])
        is_function = FactRelation('IsFunction', ['function'])
        infunction = FactRelation('InFunction', ['block', 'function'])
        function_entry = FactRelation('FunctionEntry', ['block'])
        function_modifier = FactRelation('Function_Modifier', ['function', 'modifier', 'n'])
        node_expression = FactRelation('Block_Expression', ['block', 'expression'])
        localblockedge = FactRelation('LocalBlockEdge', ['block', 'next_block'])
        fallthroughedge = FactRelation('FallthroughEdge', ['block', 'next_block'])
        isvariable = FactRelation('IsVariable', ['variable'])
        contract_variables = FactRelation('Contract_Variable', ['contract', 'global'])
        variable_signature = FactRelation('Variable_Signature', ['variable', 'visibility', 'scope', 'variable_name', 'type_id'])

        statement_defines = FactRelation('Statement_Defines', ['statement', 'variable', 'n'])
        statement_next = FactRelation('Statement_Next', ['statement', 'statement2'])
        statement_uses = FactRelation('Statement_Uses', ['statement', 'variable', 'n'])
        formalreturnargs = FactRelation('FormalReturnArgs', ['function', 'variable', 'n'])
        actualreturnargs = FactRelation('ActualReturnArgs', ['statement', 'variable', 'n'])
        formalargs = FactRelation('FormalArgs', ['function', 'variable', 'n'])
        actualargs = FactRelation('ActualArgs', ['statement', 'variable', 'n'])
        node_statement = FactRelation('Block_Statement', ['block', 'statement'])
        statement_opcode = FactRelation('Statement_Opcode', ['statement', 'opcode'])
        statement_block = FactRelation('Statement_Block', ['statement', 'block'])
        block_tail = FactRelation('Block_Tail', ['block', 'statement'])
        call_graph_edge = FactRelation('CallGraphEdge', ['block', 'function'])
        variable_value = FactRelation('Variable_Value', ['variable', 'value'])
        emit_signature = FactRelation('EmitSignature', ['statement', 'signature'])
        transfer_call = FactRelation('TransferCall', ['statement'])
        send_call = FactRelation('SendCall', ['statement'])
        precompiled_call = FactRelation('PrecompiledCall', ['statement'])
        low_level_call = FactRelation('LowLevelCall', ['statement'])
        public_call_signature = FactRelation('PublicCallSignature', ['statement', 'signature'])
        
        call_parameters = FactRelation(
            'CallParameters',
            ['statement', 'gas', 'destination', 'callvalue']
        )
        
        class StatementInsertor:
            def __init__(self):
                self.reserve_on_node = 100
                self.statement_index = self.reserve_on_node
                self.prev_ir_id = self.statement_index
                self.node = None
            
            def set_node(self, node):
                if self.node is not None:
                    block_tail.add(self.node, self.statement_index) 

                self.node = node
                self.statement_index+=self.reserve_on_node

            def insert(self):
                ir_id = self.statement_index
                statement_block.add(ir_id, self.node)
                self.statement_index+=1
                node_statement.add(node, ir_id)
                if self.prev_ir_id == (ir_id - 1):
                    statement_next.add(self.prev_ir_id, ir_id)
                self.prev_ir_id=ir_id
                return ir_id


        statement_insertor = StatementInsertor()
        
        reference_pointers = {}

        def process_variable(variable):
            # TODO: different variables
            if variable is None:
                return
            if isinstance(variable, ReferenceVariable):
                return variable.name
            if isinstance(variable, (SolidityVariableComposed, SolidityVariable)):
                id = statement_insertor.insert()
                statement_defines.add(id, id, 0)
                statement_opcode.add(id, builtin_translations[str(variable)])
                variable_signature.add(
                    id, 'None',
                    'local', '%s_%d'%(str(variable), id),
                    str(variable.type)
                )
                return id
            if isinstance(variable, Constant):
                id = statement_insertor.insert()
                statement_defines.add(id, id, 0)
                statement_opcode.add(id, Opcode('CONST', 0, 0))
                variable_value.add(id, str(variable))
                variable_signature.add(
                    id, 'None',
                    'local', 'const_%d'%id,
                    str(variable.type)
                )
                return id
            variable_signature.add(
                variable.name, str(variable.visibility),
                'local or global', str(variable.name),
                str(variable.type)
            )
            return variable.name
            
        def assign_variable_lvalue(ir_id, lvalue, n = 0):
            var_id = process_variable(lvalue)
            if not lvalue:
                return
            # we treat reference variables in a special way
            # if these correspond to storage points
            if isinstance(lvalue, ReferenceVariable) and (lvalue.node, lvalue.index) in reference_pointers:
                new_ir_id = statement_insertor.insert()
                statement_opcode.add(new_ir_id, Opcode('STORETODATASTRUCTURE', 3, 0))
                process_ir_rvalues(
                    new_ir_id,
                    reference_pointers[lvalue.node, lvalue.index] + [lvalue])
            isvariable.add(var_id)
            statement_defines.add(ir_id, var_id, n)

        def process_ir_rvalues(ir, rvalues):
            assert isinstance(rvalues, list)
            var_ids = [process_variable(rvalue) for rvalue in rvalues]
            ir_id = statement_insertor.insert()
            for n, variable_id in enumerate(var_ids):
                statement_uses.add(ir_id, variable_id, n)
                isvariable.add(variable_id)
            return ir_id


        # Note: The following two functions are mutually recursive
        def split_and_process_node(oldnode, i):
            # do the splitting
            prev_node = PrevNode(oldnode, i)
            node = NextNode(oldnode, i)
            prev_node.sons = [node]
            localblockedge.add(prev_node, node)
            process_node(node)
            return prev_node, node
        
        def process_node(node):
            statement_insertor.set_node(node)
            for i, ir in enumerate(node.irs):
                ir_id = process_ir_rvalues(ir, ir.read)
                if isinstance(ir, InternalCall):
                    # call needs to happen at the end of a basic block
                    call_graph_edge.add(node, ir.function)
                    statement_opcode.add(ir_id, Opcode('CALLPRIVATE', -1, -1))
                    assign_variable_lvalue(ir_id, ir.lvalue)
                    if i<len(node.irs)-1:
                        # if not, split the basic block
                        node, _ = split_and_process_node(node, i)
                        # node is now the left part of the split
                        break
                elif isinstance(ir, Binary):
                    statement_opcode.add(ir_id, binary_type_to_opcode[ir.type])
                    assign_variable_lvalue(ir_id, ir.lvalue)
                elif isinstance(ir, Index):
                    lvalue = ir.lvalue
                    reference_pointers[lvalue.node, lvalue.index] = ir.read
                    statement_opcode.add(ir_id, Opcode('LOADFROMDATASTRUCTURE', 2, 1))
                    assert isinstance(lvalue, ReferenceVariable), lvalue
                    statement_defines.add(ir_id, str(lvalue), 0)
                elif isinstance(ir, EventCall):
                    statement_opcode.add(ir_id, Opcode("LOG", -1, -1))
                    emit_signature.add(ir_id, ir.name)
                elif isinstance(ir, SolidityCall):
                    statement_opcode.add(ir_id, solidity_function_to_opcode[ir.function.name])
                    assign_variable_lvalue(ir_id, ir.lvalue)
                elif isinstance(ir, Transfer):
                    statement_opcode.add(ir_id, Opcode("CALL", -1, -1))
                    transfer_call.add(ir_id)
                    #TODO
                    #call_parameters.add(
                    #    ir_id, 2300, # gas
                    #    "Zero't use", ir.call_value,
                    #)
                    
                elif isinstance(ir, Balance):
                    statement_opcode.add(ir_id, Opcode("BALANCE", 0, 1))
                    assign_variable_lvalue(ir_id, ir.lvalue)
                elif isinstance(ir, Return):
                    statement_opcode.add(ir_id, Opcode("RETURN", -1, -1, PossiblyHalts = True))
                elif isinstance(ir, (Assignment, TypeConversion)):
                    statement_opcode.add(ir_id, Opcode("ASSIGN_CAST", 1, 1, Flows = True))
                    assign_variable_lvalue(ir_id, ir.lvalue)
                elif isinstance(ir, Condition):
                    statement_opcode.add(ir_id, Opcode("JUMPI", 1, 0))
                else:
                    raise NotImplementedError(ir)
            if node.expression:
                node_expression.add(node, str(node.expression))
            # of interest:
            # node.source_mapping
            assert len(node.sons) <= 2, node.sons
            for son in node.sons:
                localblockedge.add(node, son)
            if len(node.sons) == 2:
                fallthroughedge.add(node, node.sons[1])
        
        for contract in self.contracts:
            is_contract.add(contract)
            # functions
            for function in contract.functions:
                contract_function.add(contract, function)
                is_function.add(function)
                for i, modifier in enumerate(function.modifiers):
                    function_modifier.add(function, modifier, i)
                if function.nodes:
                    function_entry.add(function.nodes[0])
                for node in function.nodes:
                    infunction.add(node, function)
                    #TODO formal arguments
                    try:
                        process_node(node)
                    except Exception:
                        extype, value, tb = sys.exc_info()
                        traceback.print_exc()
                        pdb.post_mortem(tb)
                        exit()

            # modifiers
            for modifier in contract.modifiers:
                contract_modifier.add(contract, modifier)
                for node in modifier.nodes:
                    modifier_node.add(modifier, node)
                    process_node(node)

            # storage variables
            for variable in contract.variables:
                contract_variables.add(contract, variable.reference_id)
                process_variable(variable)
        statement_insertor.set_node(None) # important: flush tail
        FactRelation.print_all_datalog()
        Opcode.print_all_datalog()
        FactRelation.output_all_facts()
